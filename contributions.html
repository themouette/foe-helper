<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />
    <title>Contributions</title>
    <style type="text/css" media="screen">
      html,
      body {
        padding: 0;
        margin: 0;
      }
      #main {
        width: 1200px;
        max-width: 100vw;
        margin: auto;
        overflow-x: hidden;
      }
      #main__wrapper {
        margin: 0 30px;
        display: flex;
        flex-direction: column;
        align-items: stretch;
        justify-content: flex-start;
        overflow-x: hidden;
      }
      .header {
        text-align: center;
      }
      .header__title {
        margin: 0 0 10px 0;
        padding: 0;
      }
      .header__subtitle {
        margin: 0 0 10px 0;
        padding: 0;
      }
      #drop-area {
        width: 500px;
        height: 300px;
        border: 1px dashed #cecece;
        align-self: center;
        /* Center content */
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        /* Text style */
        color: #808080;
      }
      #drop-area:hover {
        background-color: #f7f7f7;
        color: #c0c0c0;
      }
      .drop-area__input input {
        width: 0.1px;
        height: 0.1px;
        opacity: 0;
        overflow: hidden;
        position: absolute;
        z-index: -1;
      }
      .drop-area__input label {
        display: inline-block;
        text-decoration: underline;
        text-decoration-style: dashed;
        cursor: pointer;
      }
      #result {
        white-space: pre-wrap; /* css-3 */
        white-space: -moz-pre-wrap; /* Mozilla, since 1999 */
        white-space: -pre-wrap; /* Opera 4-6 */
        white-space: -o-pre-wrap; /* Opera 7 */
        word-wrap: break-word; /* Internet Explorer 5.5+ */
      }
    </style>
  </head>
  <body>
    <div id="main">
      <div id="main__wrapper">
        <div class="header">
          <h1 class="header__title">Calcul des statistiques de trésorerie</h1>
          <p class="header__subtitle">à partir des exports FOE-helper</p>
        </div>
        <div id="drop-area">
          <div class="drop-area__label">
            Déposer les fichiers d'export ici ou
            <span class="drop-area__input">
              <label for="file-selector">Parcourir</label
              ><input type="file" id="file-selector" multiple />
            </span>
          </div>
        </div>
        <div class="toolbox">
          <h3>Filtrer</h3>
          <input
            type="hidden"
            id="timezone"
            name="timezone"
            value="Europe/Paris"
          />
          <p>
            <label
              >Afficher le détail des resources:
              <input id="resource-detail" type="checkbox"
            /></label>
          </p>
          <p>
            <label
              >date debut: <input id="start-date" type="datetime-local"
            /></label>
          </p>
          <p>
            <label
              >date fin: <input id="end-date" type="datetime-local"
            /></label>
          </p>
        </div>
        <div><pre id="result"></pre></div>
      </div>
    </div>

    <!-- https://raw.githubusercontent.com/adaltas/node-csv/79939aee56c467ab8f866eac3ebc591279b2f6f2/packages/csv/dist/iife/index.js -->
    <script src="./3rd-party/node-csv.js" charset="utf-8"></script>
    <script charset="utf-8">
      /** A global object to store application state */
      let globalState = {
        // Rows read from CSV files
        rows: [],
        // Date object used to filter results on given period
        filterStart: undefined,
        // Date object used to filter results on given period
        filterEnd: undefined,
      };

      function initToolbox() {
        document
          .querySelector("#resource-detail")
          .addEventListener("change", () => {
            refreshDisplay();
          });
        document
          .querySelector("#start-date")
          .addEventListener("change", (event) => {
            globalState.filterStart = event.target.value
              ? new Date(event.target.value)
              : undefined;
            refreshDisplay();
          });
        document.querySelector("#end-date").addEventListener("change", () => {
          globalState.filterEnd = event.target.value
            ? new Date(event.target.value)
            : undefined;
          refreshDisplay();
        });
      }
      initToolbox();

      const ages = [
        "Âge de Fer",
        "Haut Moyen Âge",
        "Moyen Âge Classique",
        "Renaissance",
        "Âge Colonial",
        "Âge Industriel",
        "Ère Progressiste",
        "Ère Moderne",
        "Ère Postmoderne",
        "Ère Contemporaine",
        "Ère de Demain",
        "Ère du Futur",
        "Futur Arctique",
        "Futur Océanique",
        "Futur Virtuel",
        "Ère Spatiale - Mars",
        "Ère Spatiale - Ceinture d'Astéroïdes",
        "Ère Spatiale - Vénus",
        "Ère Spatiale - Lune de Jupiter",
        "Ère Spatiale - Titan",
      ];
      const mapResourceToEra = {
        Tissu: "Âge de Fer",
        "Bois d'ébène": "Âge de Fer",
        Bijou: "Âge de Fer",
        Fer: "Âge de Fer",
        Calcaire: "Âge de Fer",
        Cuivre: "Haut Moyen Âge",
        Or: "Haut Moyen Âge",
        Granite: "Haut Moyen Âge",
        Miel: "Haut Moyen Âge",
        Albâtre: "Haut Moyen Âge",
        Brique: "Moyen Âge Classique",
        Verre: "Moyen Âge Classique",
        "Herbes séchées": "Moyen Âge Classique",
        Corde: "Moyen Âge Classique",
        Sel: "Moyen Âge Classique",
        Basalte: "Renaissance",
        Laiton: "Renaissance",
        "Poudre à canon": "Renaissance",
        Soie: "Renaissance",
        "Poudre à talquer": "Renaissance",
        Café: "Âge Colonial",
        Papier: "Âge Colonial",
        Porcelaine: "Âge Colonial",
        Goudron: "Âge Colonial",
        Fil: "Âge Colonial",
        Coke: "Âge Industriel",
        Engrais: "Âge Industriel",
        Caoutchouc: "Âge Industriel",
        Textiles: "Âge Industriel",
        "Huile de baleine": "Âge Industriel",
        Amiante: "Ère Progressiste",
        Explosifs: "Ère Progressiste",
        "Pièces détachées": "Ère Progressiste",
        Essence: "Ère Progressiste",
        "Fer-blanc": "Ère Progressiste",
        "Plat cuisiné": "Ère Moderne",
        "Béton armé": "Ère Moderne",
        Arômes: "Ère Moderne",
        "Produits de luxe": "Ère Moderne",
        Emballage: "Ère Moderne",
        "Donnée génétique": "Ère Postmoderne",
        "Filtres industriels": "Ère Postmoderne",
        "Ressources renouvelables": "Ère Postmoderne",
        "Semi-conducteurs": "Ère Postmoderne",
        Acier: "Ère Postmoderne",
        "Donnée bionique": "Ère Contemporaine",
        "Électro-aimants": "Ère Contemporaine",
        Gaz: "Ère Contemporaine",
        Plastique: "Ère Contemporaine",
        Robots: "Ère Contemporaine",
        "Recherche en nutrition": "Ère de Demain",
        "Liant papier": "Ère de Demain",
        Conservateurs: "Ère de Demain",
        "Matériaux intelligents": "Ère de Demain",
        "Béton translucide": "Ère de Demain",
        Algue: "Ère du Futur",
        "Donnée biogéochimique": "Ère du Futur",
        Nanoparticules: "Ère du Futur",
        "Eau purifiée": "Ère du Futur",
        Supraconducteurs: "Ère du Futur",
        "Donnée d'I.A.": "Futur Arctique",
        Bioplastiques: "Futur Arctique",
        Nanocâble: "Futur Arctique",
        "Piles en papier": "Futur Arctique",
        "Gaz transester": "Futur Arctique",
        "Écailles artificielles": "Futur Océanique",
        "Substance bioluminescente": "Futur Océanique",
        Coraux: "Futur Océanique",
        Perles: "Futur Océanique",
        Plancton: "Futur Océanique",
        "Crypto-monnaie": "Futur Virtuel",
        "Cristaux de données": "Futur Virtuel",
        "Riz doré": "Futur Virtuel",
        Nanorobots: "Futur Virtuel",
        "Soie de thé": "Futur Virtuel",
        "Cultures biotechnologiques": "Ère Spatiale - Mars",
        "Réacteurs de fusion": "Ère Spatiale - Mars",
        "Huiles de graissage": "Ère Spatiale - Mars",
        "Microbes martiens": "Ère Spatiale - Mars",
        Superalliages: "Ère Spatiale - Mars",
        Brome: "Ère Spatiale - Ceinture d'Astéroïdes",
        "Fluide composé": "Ère Spatiale - Ceinture d'Astéroïdes",
        Nickel: "Ère Spatiale - Ceinture d'Astéroïdes",
        "Cristal de platine": "Ère Spatiale - Ceinture d'Astéroïdes",
        "Matériau transformé": "Ère Spatiale - Ceinture d'Astéroïdes",
        "Algue lumineuse": "Ère Spatiale - Vénus",
        "En-cas d'herbe": "Ère Spatiale - Vénus",
        "Suppléments de micropousse": "Ère Spatiale - Vénus",
        "Protéines de soja": "Ère Spatiale - Vénus",
        "Cristaux de sucre": "Ère Spatiale - Vénus",
        "Données ADN avancées": "Ère Spatiale - Lune de Jupiter",
        "Créatures biologiques": "Ère Spatiale - Lune de Jupiter",
        "Porifère avancé": "Ère Spatiale - Lune de Jupiter",
        "Algues rouges": "Ère Spatiale - Lune de Jupiter",
        "Dossiers topologiques": "Ère Spatiale - Lune de Jupiter",
        "Capsule de matière comprimée": "Ère Spatiale - Titan",
        "Donnée expérimentale": "Ère Spatiale - Titan",
        "Molécule isolée": "Ère Spatiale - Titan",
        "Liant liquide": "Ère Spatiale - Titan",
        "Hydrocarbure upcyclé": "Ère Spatiale - Titan",
      };
      const mapEraToShortName = {
        "Âge de Fer": "AdF",
        "Haut Moyen Âge": "HMA",
        "Moyen Âge Classique": "MA Classique",
        Renaissance: "Renaissance",
        "Âge Colonial": "Colo",
        "Âge Industriel": "Indus",
        "Ère Progressiste": "Progressiste",
        "Ère Moderne": "Moderne",
        "Ère Postmoderne": "Postmoderne",
        "Ère Contemporaine": "Contemporaine",
        "Ère de Demain": "Demain",
        "Ère du Futur": "Futur",
        "Futur Arctique": "FA",
        "Futur Océanique": "FO",
        "Futur Virtuel": "FV",
        "Ère Spatiale - Mars": "Mars",
        "Ère Spatiale - Ceinture d'Astéroïdes": "Astéroïdes",
        "Ère Spatiale - Vénus": "Vénus",
        "Ère Spatiale - Lune de Jupiter": "Jupiter",
        "Ère Spatiale - Titan": "Titan",
      };

      function groupResourceCountByEra(countsByResource) {
        const countsByAge = {};
        Object.keys(countsByResource).forEach((resourceName) => {
          const age = mapResourceToEra[resourceName] || "Sans Age";
          if (!mapResourceToEra[resourceName]) {
            console.log(`Resource sans age: ${resourceName}`);
          }
          const shortAgeName = mapEraToShortName[age] || age;
          countsByAge[shortAgeName] =
            (countsByAge[shortAgeName] || 0) + countsByResource[resourceName];
        });

        return countsByAge;
      }

      const fileSelector = document.getElementById("file-selector");
      fileSelector.addEventListener("change", (event) => {
        const fileList = event.target.files;
        readCsvFiles(fileList);
      });

      const dropArea = document.getElementById("drop-area");
      dropArea.addEventListener("dragover", (event) => {
        event.stopPropagation();
        event.preventDefault();
        // Style the drag-and-drop as a "copy file" operation.
        event.dataTransfer.dropEffect = "copy";
      });

      dropArea.addEventListener("drop", (event) => {
        event.stopPropagation();
        event.preventDefault();
        const fileList = event.dataTransfer.files;
        readCsvFiles(fileList);
      });
      function decodeBase64(base64) {
        const text = atob(base64);
        const length = text.length;
        const bytes = new Uint8Array(length);
        for (let i = 0; i < length; i++) {
          bytes[i] = text.charCodeAt(i);
        }
        const decoder = new TextDecoder(); // default is utf-8
        return decoder.decode(bytes);
      }
      const toNumber = (x) => Number(x.replaceAll(/[^-\d]/g, ""));
      const isNumeric = (x) => !isNaN(Number(x));
      /**
       * Parse time string in format `hh:mm`
       * const [hour, minutes] = parseTime('11:45');
       */
      const parseTime = (str) => str.split(":").map(toNumber);
      /**
       * Parse date string in format `hh:mm`
       * const date = parseDate('2023/10/22');
       * const date = parseDate('22/9/2023');
       * const date = parseDate('22-09-2023');
       */
      const parseDate = (str) => {
        const parts = str.split(/-|\//g).map(toNumber);
        // Determine the order, expect year to be over 2000
        if (parts[0] > 2000) {
          return new Date(parts[0], parts[1] - 1, parts[2], 0, 0, 0, 0);
        }
        return new Date(parts[2], parts[1] - 1, parts[0], 0, 0, 0, 0);
      };
      const formatGoods = (goods) => {
        return Object.keys(goods).map((name) => `${name} (${goods[name]})`);
      };

      function readSingleFile(file) {
        // Check if the file is CSV
        if (
          file.type &&
          !(
            (
              file.type.startsWith("text/csv") || // standard
              file.type.startsWith("application/vnd.ms-excel")
            ) // Windows...
          )
        ) {
          console.log("File is not a CSV file", file.type, file);
          return "";
        }

        return new Promise((resolve) => {
          const reader = new FileReader();
          reader.addEventListener("load", (event) => {
            let fileContent = event.target.result.replace(
              /data:[^;]*;base64,/,
              ""
            );
            fileContent = decodeBase64(fileContent).replace(
              // FR => EN
              "ID Joueur;Nom du joueur;Ère;Ressource;Montant;Message;Date/Heure",
              "Player ID;Player name;Era;Good;Amount;Message;Date/Time"
            );
            resolve({ file, fileContent });
          });
          reader.readAsDataURL(file);
        });
      }

      const daysOfWeek = [
        "dimanche",
        "lundi",
        "mardi",
        "mercredi",
        "jeudi",
        "vendredi",
        "samedi",
      ];
      const filenameRegEx = /^\d{4}-\d{1,2}-\d{1,2}/;
      /**
       * Returns a timestamp guessed from file and cell content.
       *
       * Accepts formats like:
       * - `hier à 11:48`
       * - `aujourd'hui à 14:12`
       * - `Mardi à 12:12`
       * - `le 11/12/2013 à 15:23`
       *
       * Alway round timestamp to minute as there is no information about
       * seconds in datasource.
       */
      function guessTimeFromString(cellContent, file) {
        // Assume file is named `YYYY-MM-DD.*`
        if (!filenameRegEx.test(file.name)) {
          return cellContent;
        }
        const fileDate = parseDate(file.name.slice(0, 10));

        const cellTxt = cellContent.toLowerCase();

        if (cellTxt.startsWith("aujourd'hui à ")) {
          const [hours, minutes] = parseTime(
            cellTxt.replace("aujourd'hui à ", "")
          );
          fileDate.setHours(hours);
          fileDate.setMinutes(minutes);
          return fileDate.getTime();
        } else if (cellTxt.startsWith("hier à ")) {
          const [hours, minutes] = parseTime(cellTxt.replace("hier à ", ""));
          fileDate.setDate(fileDate.getDate() - 1);
          fileDate.setHours(hours);
          fileDate.setMinutes(minutes);
          return fileDate.getTime();
        } else if (cellTxt.startsWith("le ")) {
          const [dateStr, timeStr] = cellTxt.replace("le ", "").split(" à ");
          const [hours, minutes] = parseTime(timeStr);
          const date = parseDate(dateStr);
          date.setHours(hours);
          date.setMinutes(minutes);
          return date.getTime();
        } else if (cellTxt.includes(" à ")) {
          // Starts with day of week
          const [dayOfWeek, dayTime] = cellTxt.split(" à ");
          const fileDateDayOfWeek = fileDate.getDay();
          // Hacky way to get the number of days to remove to file date.
          const rowDayModifier =
            (daysOfWeek.indexOf(dayOfWeek) - fileDateDayOfWeek - 7) % 7;
          const [hours, minutes] = parseTime(dayTime);
          fileDate.setDate(fileDate.getDate() + rowDayModifier);
          fileDate.setHours(hours);
          fileDate.setMinutes(minutes);
          return fileDate.getTime();
        } else {
          return cellTxt;
        }
      }

      function csvToJson({ file, fileContent: csvString }) {
        return new Promise((resolve, reject) => {
          csv.parse(
            csvString,
            { delimiter: ";", columns: true },
            (err, result) => {
              if (err) return reject(err);
              resolve(result);
            }
          );
        }).then(
          /* change date/time column to a timestamp guessed from file created time */
          (rows) =>
            rows.map((row) => ({
              ...row,
              timestamp: guessTimeFromString(row["Date/Time"], file),
            }))
        );
      }
      function compileStatsFromRows(state) {
        const { rows, filterStart, filterEnd } = state;
        console.log(rows);
        // Group by member
        // each member is an object:
        // {
        //   monuments: { algues: 12, ... },
        //   donnation: { algues: 12, ... },
        //   total: 123
        // }
        const byMember = {};
        // Global guild statistics
        // {
        //   donnation: { algues: 12, ... },
        //   monuments: { algues: 12, ... },
        //   cdg: { algues: 12, ... },
        //   gcg: {},
        //   eg: {},
        //   unknownEvents: [],
        //   total_contributions: 123,
        //   total_spent: 110,
        //   balance: {},
        // }
        const stats = {
          all: {},
          monuments: {},
          donnation: {},
          cdg: {},
          eg: {},
          gcg: {},
          unknownEvents: [],
          total_contributions: 0,
          total_spent: 0,
          balance: 0,
          from: new Date(rows[rows.length - 1].timestamp).toLocaleString(
            "fr-FR"
          ),
          to: new Date(rows[0].timestamp).toLocaleString("fr-FR"),
        };

        rows
          .filter(
            ({ timestamp }) =>
              (!filterEnd || timestamp < filterEnd) &&
              (!filterStart || timestamp > filterStart)
          )
          .forEach(({ Message, Good, "Player name": playerName, Amount }) => {
            byMember[playerName] = byMember[playerName] || {
              monuments: {},
              donnation: {},
              total: 0,
            };

            stats.balance += toNumber(Amount);
            stats.all[Good] = (stats.all[Good] || 0) + toNumber(Amount);
            if (toNumber(Amount) < 0) {
              stats.total_spent -= toNumber(Amount);
            } else {
              byMember[playerName].total += toNumber(Amount);
              stats.total_contributions += toNumber(Amount);
            }

            if (Message === "Production de bâtiment") {
              byMember[playerName].monuments[Good] =
                (byMember[playerName].monuments[Good] || 0) + toNumber(Amount);
              stats.monuments[Good] =
                (stats.monuments[Good] || 0) + toNumber(Amount);
            } else if (Message === "Dons à la trésorerie de la guilde") {
              byMember[playerName].donnation[Good] =
                (byMember[playerName].donnation[Good] || 0) + toNumber(Amount);
              stats.donnation[Good] =
                (stats.donnation[Good] || 0) + toNumber(Amount);
            } else if (Message.startsWith("Champs de bataille")) {
              stats.cdg[Good] = (stats.cdg[Good] || 0) + toNumber(Amount);
            } else if (Message.startsWith("Déploiement de l'armée de siège")) {
              stats.gcg[Good] = (stats.gcg[Good] || 0) + toNumber(Amount);
            } else if (Message.startsWith("Expédition de guilde")) {
              stats.eg[Good] = (stats.eg[Good] || 0) + toNumber(Amount);
            } else {
              stats.unknownEvents = [...stats.unknownEvents, Message];
            }
          });

        return { byMember, ...stats };
      }

      function formatStats({ byMember, ...stats }) {
        const resourceOrAge = document.querySelector("#resource-detail").checked
          ? (resourceMap) => resourceMap
          : groupResourceCountByEra;

        const allStats = resourceOrAge(stats.all);
        const donnations = Object.keys(byMember).reduce(
          (acc, memberName) => ({
            ...acc,
            [memberName]: resourceOrAge(byMember[memberName].donnation),
          }),
          {}
        );

        return `
Campagne du ${stats.from} au ${stats.to}

Bilan: ${stats.total_contributions} - ${stats.total_spent} = ${stats.balance}

Detail des variations de resources:
${Object.keys(allStats)
  .sort((nameA, nameB) => allStats[nameA] - allStats[nameB])
  .map((name) => `- ${name} (${allStats[name]})\n`)
  .join("")}

Dons:
${Object.keys(donnations)
  .filter((name) => Object.keys(donnations[name]).length > 0)
  .map((name) => `- ${name}: ${formatGoods(donnations[name])}\n`)
  .join("")}

Contribution des membres:
${Object.keys(byMember)
  .map((name) => `- ${name}: (${byMember[name].total})\n`)
  .join("")}

Batiments Champs de bataille:
- ${formatGoods(resourceOrAge(stats.cdg)).join("\n- ")}

Expédition de guilde:
- ${formatGoods(resourceOrAge(stats.eg)).join("\n- ")}

Continent Des Guildes:
- ${formatGoods(resourceOrAge(stats.gcg)).join("\n- ")}

${
  stats.unknownEvents.length
    ? "Evenements inconnus:\n - " +
      Array.from(new Set(stats.unknownEvents)).join("\n - ")
    : ""
}
                          `;
      }

      function combineAndDedupeFiles(filesAsJson) {
        /* Most recent first */
        const sortFunction = (a, b) => {
          if (isNumeric(b.timestamp) && isNumeric(b.timestamp)) {
            return b.timestamp - a.timestamp;
          }
          if (isNumeric(b.timestamp)) {
            return -1;
          }
          if (isNumeric(a.timestamp)) {
            return 1;
          }
          return b.timestamp.length - a.timestamp.length;
        };
        return filesAsJson
          .map((rows) => rows.sort(sortFunction))
          .sort((a, b) => sortFunction(a[0], b[0]))
          .flatMap((rows, index, sortedFileList) => {
            // given this is sorted, remove all rows with a timestamp after
            // previous file last item.
            if (!index) {
              // this is the first, there were no prior element
              return rows;
            }

            // Attempt to find last timestamp of existing file
            const lastTimestamp = sortedFileList[index - 1].findLast(
              (item) => !isNaN(Number(item.timestamp))
            )?.timestamp;
            // If timestamp was not parsed, do not filter anything
            if (!lastTimestamp || !isNumeric(lastTimestamp)) {
              return rows;
            }

            // There were a timestamp for last file,
            // Exclude all rows happening after lastTimestamp
            return rows.filter((row) => {
              if (isNumeric(row.timestamp) && row.timestamp > lastTimestamp) {
                console.log("exclude row in combineAndDedupeFiles");
                return false;
              }
              return true;
            });
          })
          .sort(sortFunction);
      }

      function readCsvFiles(files) {
        Promise.all(Array.from(files).map(readSingleFile))
          .then((csvStrings) => Promise.all(csvStrings.map(csvToJson)))
          .then(combineAndDedupeFiles)
          .then((rows) => {
            globalState.rows = rows;
          })
          .then(updateToolbox)
          .then(refreshDisplay)
          .catch((error) => console.log(error));
      }

      function updateToolbox() {
        const formatDateForInput = (o_date) =>
          `${o_date.getFullYear().toString().padStart(2, "0")}-${(
            o_date.getMonth() + 1
          )
            .toString()
            .padStart(2, "0")}-${o_date
            .getDate()
            .toString()
            .padStart(2, "0")} ${o_date
            .getHours()
            .toString()
            .padStart(2, "0")}:${o_date
            .getMinutes()
            .toString()
            .padStart(2, "0")}:${o_date
            .getSeconds()
            .toString()
            .padStart(2, "0")}`;
        const { rows } = globalState;
        const from = formatDateForInput(
          new Date(rows[rows.length - 1].timestamp)
        );
        const to = formatDateForInput(new Date(rows[0].timestamp));

        document.querySelector("#start-date").setAttribute("value", from);
        document.querySelector("#end-date").setAttribute("value", to);
        /*
      // This seems to work, but UI requires more polish.
      // let's disable it.
        document.querySelector("#start-date").setAttribute("min", from);
        document.querySelector("#start-date").setAttribute("max", to);
        document.querySelector("#end-date").setAttribute("min", from);
        document.querySelector("#end-date").setAttribute("max", to);
        */
      }

      function refreshDisplay() {
        Promise.resolve(globalState)
          .then(compileStatsFromRows)
          .then(formatStats)
          .then(
            (content) => (document.querySelector("#result").innerText = content)
          )
          .catch((error) => console.log(error));
      }
    </script>
  </body>
</html>
